from collections import OrderedDict
from datetime import datetime, timedelta
from typing import Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, Union, TypeVar

from django.db.models.lookups import Lookup
from django.db.models.sql.compiler import SQLCompiler

from django.db.models import Q, QuerySet
from django.db.models.fields import Field, FloatField
from django.db.models.sql import Query

_OutputField = Union[Field, str]

class SQLiteNumericMixin:
    def as_sqlite(self, compiler: SQLCompiler, connection: Any, **extra_context: Any) -> Tuple[str, List[float]]: ...

_SelfCombinable = TypeVar("_SelfCombinable", bound="Combinable")

class Combinable:
    ADD: str = ...
    SUB: str = ...
    MUL: str = ...
    DIV: str = ...
    POW: str = ...
    MOD: str = ...
    BITAND: str = ...
    BITOR: str = ...
    BITLEFTSHIFT: str = ...
    BITRIGHTSHIFT: str = ...
    def __neg__(self: _SelfCombinable) -> _SelfCombinable: ...
    def __add__(
        self: _SelfCombinable, other: Optional[Union[timedelta, Combinable, float, str]]
    ) -> _SelfCombinable: ...
    def __sub__(self: _SelfCombinable, other: Union[timedelta, Combinable, float]) -> _SelfCombinable: ...
    def __mul__(self: _SelfCombinable, other: Union[timedelta, Combinable, float]) -> _SelfCombinable: ...
    def __truediv__(self: _SelfCombinable, other: Union[Combinable, float]) -> _SelfCombinable: ...
    def __itruediv__(self: _SelfCombinable, other: Union[Combinable, float]) -> _SelfCombinable: ...
    def __mod__(self: _SelfCombinable, other: Union[int, Combinable]) -> _SelfCombinable: ...
    def __pow__(self: _SelfCombinable, other: Union[float, Combinable]) -> _SelfCombinable: ...
    def __and__(self: _SelfCombinable, other: Combinable) -> _SelfCombinable: ...
    def bitand(self: _SelfCombinable, other: int) -> _SelfCombinable: ...
    def bitleftshift(self: _SelfCombinable, other: int) -> _SelfCombinable: ...
    def bitrightshift(self: _SelfCombinable, other: int) -> _SelfCombinable: ...
    def __or__(self: _SelfCombinable, other: Combinable) -> _SelfCombinable: ...
    def bitor(self: _SelfCombinable, other: int) -> _SelfCombinable: ...
    def __radd__(self, other: Optional[Union[datetime, float, Combinable]]) -> Combinable: ...
    def __rsub__(self, other: Union[float, Combinable]) -> Combinable: ...
    def __rmul__(self, other: Union[float, Combinable]) -> Combinable: ...
    def __rtruediv__(self, other: Union[float, Combinable]) -> Combinable: ...
    def __rmod__(self, other: Union[int, Combinable]) -> Combinable: ...
    def __rpow__(self, other: Union[float, Combinable]) -> Combinable: ...
    def __rand__(self, other: Any) -> Combinable: ...
    def __ror__(self, other: Any) -> Combinable: ...

_SelfBaseExpression = TypeVar("_SelfBaseExpression", bound="BaseExpression")

class BaseExpression:
    is_summary: bool = ...
    filterable: bool = ...
    window_compatible: bool = ...
    def __init__(self, output_field: Optional[_OutputField] = ...) -> None: ...
    def get_db_converters(self, connection: Any) -> List[Callable]: ...
    def get_source_expressions(self) -> List[Any]: ...
    def set_source_expressions(self, exprs: List[Any]) -> None: ...
    def contains_aggregate(self) -> bool: ...
    def contains_over_clause(self) -> bool: ...
    def contains_column_references(self) -> bool: ...
    def resolve_expression(
        self,
        query: Any = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> BaseExpression: ...
    @property
    def field(self) -> Field: ...
    @property
    def output_field(self) -> Field: ...
    def convert_value(self) -> Callable: ...
    def get_lookup(self, lookup: str) -> Optional[Type[Lookup]]: ...
    def get_transform(self, name: str) -> Optional[Type[Expression]]: ...
    def relabeled_clone(self, change_map: Dict[Optional[str], str]) -> Expression: ...
    def copy(self) -> BaseExpression: ...
    def get_group_by_cols(self: _SelfBaseExpression) -> List[_SelfBaseExpression]: ...
    def get_source_fields(self) -> List[Optional[Field]]: ...
    def asc(self, **kwargs: Any) -> Expression: ...
    def desc(self, **kwargs: Any) -> Expression: ...
    def reverse_ordering(self): ...
    def flatten(self) -> Iterator[Expression]: ...
    def __hash__(self) -> int: ...
    def deconstruct(self) -> Any: ...
    def as_sqlite(self, compiler: SQLCompiler, connection: Any) -> Any: ...
    def as_sql(self, compiler: SQLCompiler, connection: Any, **extra_context: Any) -> Any: ...
    def as_mysql(self, compiler: Any, connection: Any) -> Any: ...
    def as_postgresql(self, compiler: Any, connection: Any) -> Any: ...
    def as_oracle(self, compiler: Any, connection: Any): ...

class Expression(BaseExpression, Combinable): ...

class CombinedExpression(SQLiteNumericMixin, Expression):
    connector: Any = ...
    lhs: Any = ...
    rhs: Any = ...
    def __init__(
        self, lhs: Combinable, connector: str, rhs: Combinable, output_field: Optional[_OutputField] = ...
    ) -> None: ...
    def get_source_expressions(self) -> Union[List[Combinable], List[SQLiteNumericMixin]]: ...
    def set_source_expressions(self, exprs: List[Combinable]) -> None: ...
    def resolve_expression(
        self,
        query: Any = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> CombinedExpression: ...

class F(Combinable):
    name: str
    def __init__(self, name: str): ...
    def resolve_expression(
        self,
        query: Any = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Expression: ...
    def asc(self, **kwargs) -> OrderBy: ...
    def desc(self, **kwargs) -> OrderBy: ...
    def deconstruct(self) -> Any: ...

class OuterRef(F):
    def __init__(self, name: Union[str, OuterRef]): ...

class Subquery(Expression):
    template: str = ...
    queryset: QuerySet = ...
    extra: Dict[Any, Any] = ...
    def __init__(self, queryset: QuerySet, output_field: Optional[_OutputField] = ..., **extra: Any) -> None: ...

class Exists(Subquery):
    extra: Dict[Any, Any]
    template: str = ...
    negated: bool = ...
    def __init__(self, *args: Any, negated: bool = ..., **kwargs: Any) -> None: ...
    def __invert__(self) -> Exists: ...

class OrderBy(BaseExpression):
    template: str = ...
    nulls_first: bool = ...
    nulls_last: bool = ...
    descending: bool = ...
    expression: Expression = ...
    def __init__(
        self, expression: Combinable, descending: bool = ..., nulls_first: bool = ..., nulls_last: bool = ...
    ) -> None: ...

class Value(Expression):
    value: Any = ...
    def __init__(self, value: Any, output_field: Optional[_OutputField] = ...) -> None: ...

class RawSQL(Expression):
    output_field: Field
    params: List[Any]
    sql: str
    def __init__(self, sql: str, params: Sequence[Any], output_field: Optional[_OutputField] = ...) -> None: ...

class Func(SQLiteNumericMixin, Expression):
    function: str = ...
    template: str = ...
    arg_joiner: str = ...
    arity: int = ...
    source_expressions: List[Expression] = ...
    extra: Dict[Any, Any] = ...
    def __init__(self, *expressions: Any, output_field: Optional[_OutputField] = ..., **extra: Any) -> None: ...
    def get_source_expressions(self) -> List[Combinable]: ...
    def set_source_expressions(self, exprs: List[Expression]) -> None: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[Any]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Func: ...
    def copy(self) -> Func: ...

class When(Expression):
    template: str = ...
    condition: Any = ...
    result: Any = ...
    def __init__(self, condition: Any = ..., then: Any = ..., **lookups: Any) -> None: ...

class Case(Expression):
    template: str = ...
    case_joiner: str = ...
    cases: Any = ...
    default: Any = ...
    extra: Any = ...
    def __init__(
        self, *cases: Any, default: Optional[Any] = ..., output_field: Optional[_OutputField] = ..., **extra: Any
    ) -> None: ...

class ExpressionWrapper(Expression):
    def __init__(self, expression: Union[Q, Combinable], output_field: _OutputField): ...
    def set_source_expressions(self, exprs: Sequence[Expression]) -> None: ...
    def get_source_expressions(self) -> List[Expression]: ...

class Col(Expression):
    def __init__(self, alias: str, target: str, output_field: Optional[_OutputField] = ...): ...

class ExpressionList(Func):
    def __init__(self, *expressions: Union[BaseExpression, Combinable], **extra: Any) -> None: ...

class Random(Expression):
    output_field: FloatField

class Ref(Expression):
    def __init__(self, refs: str, source: Expression): ...
